[latex]Applications of $post(\phi, \rho)$:\begin{enumerate}    \item $\rho$ has no primed variables:\\     $post(\phi, \rho) = $?    \item $\rho$ has only primed variables:\\     $post(\phi, \rho) = $?    \item $\rho$ is an update of  $x$ by an expression $e$ without $x$, say$\rho= x:=e(y,z)$:\\     $post(\phi, \rho) = $?\end{enumerate}[/latex]  	[latex]\begin{enumerate}    \item $\rho$ has no primed variables:\\     $post(\phi, \rho) = \phi \wedge rho$    \item $\rho$ has only primed variables:\\     $post(\phi, \rho) = \rho[V/V']$    \item $\rho$ is an update of  $x$ by an expression $e$ without $x$, say$\rho= x:=e(y,z)$:\\     $post(\phi, \rho) = \exists x \phi \wedge x = e$\end{enumerate}[/latex]
Safe inductive invariant  	[latex]\begin{itemize}    \item program is safe if there exists safe inductive invariant $\varphi$    \item inductive:\begin{equation*}\varphi_{init} \models \varphi \text{ and } post(\varphi, \rho_{\mathcal{P}}\models \varphi\end{equation*}\item safe:\begin{equation*}\varphi \wedge \varphi_{err} \models false\end{equation*}\item justification:\begin{enumerate}    \item "$\varphi_{reach}$ is strongest inductive invariant"\begin{equation*}\varphi_{reach} \models \varphi\end{equation*}\item program safe if $\varphi_{reach}$ does not contain an error state:\begin{equation*}\varphi_{reach} \wedge \varphi_{err} \models false\end{equation*}\end{enumerate}\end{itemize}[/latex]
Examples of inductive invariants  	[latex]\begin{enumerate}    \item weakest inductive invariant: $true$ (set of all states) $=$ contains           error states    \item strongest inductive invariant: $\varphi_{reach}$ $=$ if contains          error states then program is not safe    \item there can be weaker inductive invariants that also suffice to prove          safety $=$ motivation for abstractions\end{enumerate}[/latex]
Fixpoint interation  	[latex]\begin{enumerate}    \item computation of reachable proram states $=$ iterative application of$post$ on initial program states until fixpoint is reached (no new programstates obtained by applying $post$)    \item in general, iteration process \emph{does not converge} $=$ may notreach fixpoint in finite number of iterations\end{enumerate}[/latex]
[latex]Abstraction of $\varphi_{reach}$ by $\varphi_{reach}^{\#}$[/latex] 	[latex]\begin{itemize}    \item instead of computing $\varphi_{reach}$ compute over-approximation$\varphi_{reach}^{\#}$ s.t $\varphi_{reach} \subseteq \varphi_{reach}^{\#}$    \item check if $\varphi_{reach}^{\#}$ contains any error states    \item if $\varphi_{reach}^{\#} \wedge \varphi_{err} \models false$ holdsthen $\varphi_{reach} \wedge \varphi_{err} \models fals$ holds too and theprogram is safe (since any reachable state is contained in theover-approximation)    \item compute $\varphi_{reach}^{\#}$ by applying iteration    \item instead of iterativly applying compost, use over-approximation$post^{\#}$ s.t. always:\begin{equation*}post(\varphi, \rho) \models \post^{\#}(\varphi, \rho)\end{equation*}\item decompose computation of $post^{\#}$ in two steps:\\\begin{enumerate}    \item apply normal $post$    \item then over-approximate result using function $\alpha$ s.t.:\begin{equation*}\forall \varphi: \varphi \models \alpha(\varphi)\end{equation*}\end{enumerate}\end{itemize}[/latex]
[latex]Abstraction of $post$ by $post^{\#}$[/latex] 	[latex]\begin{enumerate}    \item given abstraction function $\alpha$, let:\begin{equation*}post^{\#}(\varphi, \rho) = \alpha(post(\varphi, \rho))\end{equation*}    \item compute $\varphi_{reach}^{\#}$:\begin{equation*}\varphi_{reach}^{\#} &= \bigvee \limits_{i \geq0}(post^{\#})^i(\alpha(\varphi_{init}), \rho_{\mathcal{P}})\end{equation*}\item consequence: $\varphi_{reach} \models \varphi_{reach}^{\#}\end{enumerate}[/latex]
